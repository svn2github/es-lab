\documentclass{llncs}
\usepackage{makeidx}  
\usepackage{ifthen}
\usepackage{amssymb}

\newboolean{showcomments}
\setboolean{showcomments}{true}
\ifthenelse{\boolean{showcomments}}
  {\newcommand{\bnote}[2]{
	\fbox{\bfseries\sffamily\scriptsize#1}
    {\sf\small$\blacktriangleright$\textit{#2}$\blacktriangleleft$}
   }
  }
  {\newcommand{\bnote}[2]{}
  } 

% \usepackage{hyperref}
\begin{document}
\sloppypar


\title{Distributed Electronic Rights in JavaScript:\\
A Progress Report}

\author{Mark S. Miller\inst{1} \and Tom Van Cutsem\inst{2} \and Bill Tulloh\inst{3} }

\institute{Google, Inc. \and Vrije Universiteit Brussel \and George Mason University}

\maketitle    

\begin{abstract}

Smart Contracts are cool. \bnote{Mark}{need a real abstract}

\keywords{security, distributed objects, capabilities, smart contracts}
\end{abstract}

\section{Smart Contracts for the Rest of Us}

The fabric of the global economy is held together by contracts. A contract is an agreed arrangement for cooperation between mutually suspicious parties. But existing contracts are ambiguous, jurisdictions-specific, and written, interpreted, and adjudicated only by expensive experts. \emph{Smart contracts} are contract-like arrangements expressed in program code, where the behavior of the program enforces the terms of the ``contract''\cite{szabo1997formalizing}. Though not a substitute for legal contracts, they can provide some of the benefits of contracts for fine-grain, jurisdiction-free, and automated arrangements for which legal contracts are impractical.

To realize this potential, smart contracts themselves need a distributed, secure, persistent, and ubiquitous computational fabric. To avoid merely substituting one set of expensive experts for another, non-experts should be able to write smart contracts understandable by other non-experts.

We are working towards turning JavaScript into such a fabric. JavaScript is already understood and used by massive numbers of non-expert programmers. We call our target JavaScript platform \emph{Dr. SES} for \emph{Distributed Resilient Secure EcmaScript}\footnote{The official standards name for JavaScript is ``EcmaScript''.}. We explain how it relates to today's JavaScript, and report on our progress building Dr. SES. To demonstrate that Dr. SES would be a suitable platform, we present a representative simple smart contract, \emph{secure distributed escrow exchange}, implemented in only 41 lines of straightforward JavaScript code. We also present a generic contract host, able to host this contract and others, in only 36 lines.

\section{Why Dr. SES?}

Dr. SES is a platform for distributed, resilient and secure computing, layered on top of EcmaScript. Let us first discuss why each of these ingredients is needed to achieve electronic rights and contracts.

Dr. SES is layered on top of EcmaScript for two primary reasons. First is the ubiquity of the language. Due to its embedding in the browser, EcmaScript is available on a wide range of platforms and devices. Second, because of this ubiquity, Javascript is widely adopted among developers and is thus accessible to a large audience of developers, many of whom are not expert programmers.

When trying to express electronic rights or contracts, it should be fairly obvious that security must play a key role in the architecture. Dr. SES builds upon the object-capability paradigm. Capability principles are followed both to secure distributed objects as well as to secure the local execution environment. The latter allows Dr. SES programs to execute mobile code from untrusted parties without fear of granting unprivileged access to that piece of code. This is especially relevant in the context of Javascript, where mobile code is routinely sent from servers to clients. In Section~\ref{sec:contract_host}, we will show an example that wholly depends on the ability to safely execute third-party code.

Javascript is not a distributed programming language. In the browser, a large number of APIs is available to scripts to communicate with servers and other frames, but these APIs are tedious to work with, and hard to secure. That is why Dr. SES extends the Javascript language proper with a handful of features to support distributed programming at the level of individual objects.

Finally, the resilience aspect of Dr. SES deals with the unavoidable issues of failure handling that come up in distributed systems. It is widely appreciated that writing correct, bug-free code in the presence of arbitrary failures is hard. Dr. SES, then, tries to make it as easy as possible for non-experts to deal with distributed failures. To a first approximation, Dr. SES does so by allowing programmers to pretend that failures do not exist.

Dr. SES has nothing to do with electronic rights or contracts per se. Its focus is to make distributed programming in Javascript as effortless as possible. Given such a platform, it then becomes possible to implement contracts with very little code. This is precisely what we will demonstrate in the second part of this paper, after having explained Dr. SES in more detail.

\section{Dr. SES: Distributed Resilient Secure EcmaScript}

The current JavaScript standard, EcmaScript 5 (ES5), enables the \emph{SES} library to easily enforce local object-capability security rules on newly loaded JavaScript code. The \emph{Q} library turns JavaScript into a securable distributed object system, spanning both browsers and servers. The \emph{NodeKen} project is layering the Node server-side JavaScript implementation onto the Ken system for distributed orthogonal persistence---resilient against many failures. We explain each below.

\subsection{Just Enough JavaScript}

JavaScript is a complex language, but this paper depends only on a small subset with two core constructs, \emph{functions} and \emph{records}. 

For the sake of brevity, this paper borrows two syntactic conveniences proposed for ES6, \emph{rest arguments}(``{\tt \ldots}'') and \emph{arrow functions}(``{\tt =>}''), and one proposed for ES7, the \emph{eventual-send operator}(``{\tt !}''). Expanding away these three conveniences, all the code here is working ES5 code, and is available at \\
{\tt code.google.com/p/es-lab/source/browse/trunk/src/ses/\#ses} \\
and its {\tt contract} subdirectory.

\paragraph{Rest arguments.} ES6 provides ``{\tt \ldots}'' as a syntactic convenience for applying a function to an array of arguments. The following three lines are equivalent, but the second line is of historic interest only.

\begin{verbatim}
  foo(3, 5)                 // normal fixed arity function call
  foo.apply(void 0, [3, 5]) // old way to apply to an array
  foo(...[3, 5])            // ES6 rest args used in this paper
\end{verbatim}

\paragraph{Arrow functions.} The following five lines all define a one parameter function which returns double its parameter. All bind a local variable named ``{\tt double}'' to this function. The first two lines are of historic interest only. This paper uses only the arrow function syntax of the last three lines.

\begin{verbatim}
  function double(n) { return n+n; }        // old function decl
  var double = function(n) { return n+n; }; // old function expr
  var double = (n) => { return n+n; };      // ES6 arrow function
  var double = (n) => n+n;    // non-"{" expr implicitly returned
  var double = n => n+n;      // parens optional if one param
\end{verbatim}

\paragraph{Records.} The record syntax {\tt \{x: 3, y: 4\}} is an expression that evaluates to a record with two named properties initialized to the values shown. Records and functions compose together naturally to give objects:

\begin{verbatim}
var makePoint = (x, y) => {
  return {
    getX: () => x,
    getY: () => y,
    add: other => makePoint(x + other.getX(), y + other.getY())
  };
};

var pt = makePoint(3, 5).add(makePoint(2, 7));
\end{verbatim}

A record of functions hiding variables serves as an object of methods ({\tt getX, getY, add}) hiding instance variables ({\tt x, y}). The {\tt makePoint} function serves as a class-like factory for making new point instances.


\subsection{SES: Securing JavaScript}

\bnote{Tom}{Before diving into SES details, we might want to take a moment to explain the key idea of capability-based security (maybe even briefly contrast it with ACLs). Make the point that we want scripts to be born powerless, unless endowed with references to powerful objects. That's the bootstrapping phase. Then, we want to make the point that a reference to an object should provide only the right to access its public API (encapsulation), and that only connectivity begets connectivity (that's how one acquires new capabilities). Then we can explain why we need to secure Javascript: because scripts are not born powerless, and because objects are not encapsulated.}

From a security perspective, there were three problems with such objects: 
\begin{itemize}
\item Records were fully mutable, allowing one client of a point to, for example, replace its {\tt getX} method, violating the assumptions of other clients. ES5 provides a {\tt freeze} primitive, used by the SES library to define the {\tt def} function for making a tamper proof object graph.
\item ES3 had six violations of static scoping. Three of these are fixed unconditionally by ES5. In addition, ES5 provides a \emph{strict mode}, enabled by the {\tt "use strict";} directive shown below, which fixes the remaining three violations. (Throughout the rest of this paper, strict mode is assumed without further notation.)  
\item Even aside from these scoping violations, ES3 functions were not encapsulated. However, ES5 strict functions are fully encapsulated.
\end{itemize}

\begin{verbatim}
"use strict";
var makePoint = (x, y) => {
  return def({
    getX: () => x,
    getY: () => y,
    add: other => makePoint(x + other.getX(), y + other.getY())
  });
};
\end{verbatim}

A \emph{tamper-proof} record of \emph{encapsulated} functions hiding \emph{lexical} variables serves as a \emph{defensible} object. An object is ``defensible'' if it can be straightforwardly coded to be \emph{defensively consistent}\cite{RobustComposition}, i.e., it can defend its own invariants and provide correct service to its well behaved clients despite arbitrary or malicious misbehavior by its other clients. Our revised {\tt makePoint} above makes defensively consistent points.

Other SES elements: 
All effects only by using references.
No powerful references by default -- all implicitly shared objects are transitively immutable. 

def
confine
Nat
WeakMap

\subsection{Q: Distributed JavaScript Objects}

As stated in the introduction, to realize electronic rights, we need a distributed, secure, and persistent computational fabric. We have just seen how SES can secure a local Javascript environment. Here, we focus on how to link up multiple such secured Javascript environments into a distributed system.

%Before jumping ahead to distributed programming, let us first turn to concurrent programming, which is an essential ingredient of distributed programming.

\paragraph{Communicating Event-Loop Concurrency}

On both the browser and the server, Javascript's de-facto concurrency model is based on ``shared nothing'' \emph{communicating event loops}. In the browser, every frame of a web page has its own event loop, which is used both for updating the UI (i.e. rendering HTML) and for executing scripts. ``node.js'', the most popular server-side Javascript environment, is based on a similar model, although on the server the focus is less on UI and more on asynchronous networking and file I/O.

In its most general form, an event loop consists of an event queue and a set of event handlers. The event loop processes events one by one from its queue by dispatching to the appropriate event handler. In Javascript, event handlers are usually functions registered as callbacks on certain events (e.g. button clicks or incoming XHR responses).

The processing of a single event is called a \emph{turn} of the event loop. Processing an event usually entails calling a callback function, which then runs to completion, without any interruption. Thus, turns are the smallest unit of interleaving.

A system of communicating event loops consists of multiple event loops (in the same or distributed address spaces) that communicate with each other solely by means of asynchronous message passing. The Web Workers API~\cite{webworkerspec} enables such communication among multiple isolated event loops within the same browser. On a distributed scale, a Javascript webpage communicating with a node.js server using asynchronous XHR requests or WebSockets~\cite{websocketsspec} is another example of two communicating event loops.

Dr. SES builds upon communicating event loops because this concurrency model provides adequate support for plan coordination~\cite{miller:strangers}. That is, the model makes it manageable for objects to maintain their invariants in the face of concurrent (interleaved) requests made by multiple clients.

While Javascript environments already effectively support event loop concurrency, the ECMAScript language itself has no built-in support for concurrent or distributed programming. Dr. SES thus extends Javascript with a handful of features that enable programmers to more directly express distributed interactions between individual objects.

\paragraph{Promises}

We introduce a new type of object, called a Promise, to represent both the outcome of asynchronous operations, as well as to represent remote object references. A normal Javascript direct reference may only designate an object within the same event loop. Only promises may come to designate objects in other event loops. A promise may be in one of several states:

\begin{description}
  \item[pending] when it is not yet determined what object the promise designates,
  \item[fulfilled] when it is resolved to successfully designate some object,
  \item[rejected] when it will never designate an object, for an alleged reason represented by an associated error.
\end{description}

A fulfilled or rejected promise is also called a resolved promise.

The function \texttt{Q(target)} returns a fulfilled promise designating the \texttt{target} object. If \texttt{target} is already a promise, that same promise is returned.

Promise objects provide a method called \texttt{then} that allows eventual access to the promise's resolution. Its signature is:

\begin{verbatim}
promise.then(success(v) => result, failure(e) => result) => resultP
\end{verbatim}

This registers the functions \texttt{success} and \texttt{failure} to be called back in a later turn, when \texttt{promise} is resolved. If the promise was fulfilled with a value \texttt{v}, then \texttt{success(v)} is called. If the promise was rejected with an error \texttt{e}, then \texttt{failure(e)} is called.

\texttt{then} itself returns \texttt{resultP}, a promise for either of the callbacks' \texttt{result} value. If the callback itself throws an error, that error is used to reject \texttt{resultP}. This propagation of errors along chains of dependent promises is called promise contagion~\cite{miller:strangers}, and it is the asynchronous equivalent of propagating exceptions up the call stack.

The \texttt{failure} callback is optional. If missing, then rejecting \texttt{promise} will automatically eventually reject \texttt{resultP} with the same reason.

To make matters more concrete, if \texttt{pointP} is a promise for a local \texttt{point} object, we may construct a derived point as follows:

\begin{verbatim}
var newP = pointP.then((point) => point.add(makePoint(1,2)); });
\end{verbatim}

\paragraph{Immediate call and eventual send}

Promises may designate both local objects, and remote objects belonging to another event loop. If the promise comes to designate a local object (or a primitive value), that value can be accessed via the \texttt{.then} method.

However, if the promise comes to designate a remote object, it is not possible to resolve the promise to a local reference. Instead, one must interact with the remote object via the promise. Any such interaction must be asynchronous, to ensure that interaction between the event loops as a whole remains asynchronous.

Javascript provides many operators to interact with an object. Here, we will focus on only three: method calls, function application, and reading the value of a property. Javascript has the familiar dot operator to express local, immediate method calls, such as \texttt{point.getX()}. We introduce a corresponding infix \texttt{!} operator (named the \emph{bang} or \emph{eventually}) operator, which designates asynchronous, possibly remote interactions.

The \texttt{!} operator can be used anywhere the dot operator can be used. For instance, if \texttt{pointP} is a promise for a \texttt{point}, then \texttt{pointP ! getX()} denotes an eventual send, which enqueues a request to call the \texttt{getX()} method in the event loop of \texttt{point}. In addition, the syntax \texttt{fP ! (x,y)}, where \texttt{fP} is a promise designating a function \texttt{f}, enqueues a request to call \texttt{f(x,y)} in the event loop of \texttt{f}. The \texttt{!} operator is actually a thin veneer of syntactic sugar over a more explicit method call on the promise object:

\bnote{Mark}{I added promise.get because the escrow exchange contract uses it to obtain the two makePurse functions to Q.join.}

\begin{center}
  \begin{tabular}{|l|l|l|}
  \hline
  Immediate syntax & Eventual syntax & Expansion \\
  \hline
  \texttt{p.m(x,y)} & \texttt{p ! m(x,y)} & \texttt{Q(p).send("m",x,y)} \\
  \texttt{p(x,y)} & \texttt{p ! (x,y)} & \texttt{Q(p).send(undefined,x,y)}\\
  \texttt{p.m} & \texttt{p ! m} & \texttt{Q(p).get("m")}\\
  \hline
  \end{tabular} 
\end{center}

\paragraph{Remote object references}

A local reference to an object is guaranteed to be unique and unforgeable, and grants only access to the public interface of the designated object. This is why a local reference is effectively a capability. When a promise comes to designate a remote object, the promise effectively becomes a remote object reference. How are such references represented, and do they have the same characteristics as local references?

A first difference, already explained above, is that remote references only carry eventual message sends, not immediate method calls. A second difference is that in a distributed setting, it is impossible to guarantee unique and unforgeable references, but we can come close.

We represent remote object references as unguessable HTTPS URLs (also called YURLs or web-keys~\cite{mashing_with_permission}). Such a reference may look like \texttt{https://www.example.com/app/\#mhbqcmmva5ja3}, where the fragment segment (everything after the \texttt{\#}) is a random character string that uniquely identifies an object on the \texttt{example.com} server.

Such URLs form distributed cryptographic-capabilities. While such a URL is neither unique nor unforgeable, it nevertheless shares an important property with a local object reference: both are unguessable secrets. This implies that if you do not know the secret, you can only come to know it if somebody else who \emph{does} know the secret chooses to share it with you.

\paragraph{Promise combinators}

Just like it is useful to compose individual functions into a composite function, it is often useful to combine multiple individual promises into a single promise whose outcome depends on the individual promises. To construct such promise combinators, a final primitive is needed for programmers to define promises with a custom resolution strategy. This primitive is called \texttt{Q.promise}, and it has the following signature:

\begin{verbatim}
Q.promise( f(resolve,reject) => () ) => promise
\end{verbatim}

\texttt{Q.promise} makes a fresh promise, where the promise is initially pending. It immediately calls the argument function \texttt{f} with two functions, conventionally named \texttt{resolve} and \texttt{reject}, that can be used to either fulfil or reject this new promise explicitly.
\bnote{tom}{shouldn't \texttt{resolve} be called \texttt{fulfil}?}
\bnote{Mark}{no, because it doesn't fulfil the promise if its argument is a pending or rejected promise. By this criteria, "resolve" isn't quite the right name either, but...}

We now use \texttt{Q.promise} to define a small set of promise combinators that we will come to rely upon later, when introducing the escrow exchange contract.

\paragraph{Q.race} Given an array of promises \texttt{answerPs}, \texttt{Q.race(answerPs)} returns a promise for the resolution of whichever promise we notice has completed first.

\begin{verbatim}
Q.race = (answerPs) => {
  return Q.promise((resolve,reject) => {
    answerPs.forEach((answerP) => {
      Q(answerP).then(resolve,reject);
    });
  });
};
\end{verbatim}

For example, the call \texttt{Q.race([xP,yP]).then((v) => { print(v); })} will cause either the value of \texttt{xP} or \texttt{yP} to be printed to the screen, whichever resolves first. If neither resolves, then neither does the promise returned by \texttt{Q.race}. If the first promise to resolve is rejected, the promise returned by \texttt{Q.race} is rejected with the same reason.

\paragraph{Q.all} It is often useful to collect several promised answers, in order to react either when all the answers are ready or when any of the promises becomes rejected.

\begin{verbatim}
Q.all = (answerPs) => {
  var countDown = answerPs.length;
  var answers = [];
  if (countDown === 0) { return Q(answers); }
  return Q.promise((resolve,reject) => {
    answerPs.forEach((answerP, index) => {
      Q(answerP).then(answer => {
        answers[index] = answer;
        if (--countDown === 0) { resolve(answers); }
      }, reject);
    });
  });
};  
\end{verbatim}

For example, given \texttt{sumP = Q.all([xP,yP]).then(([x,y]) => x+y)}, if both \texttt{xP} and \texttt{yP} resolve to a number, \texttt{sumP} resolves to their sum. If neither resolves, then neither does \texttt{sumP}. If either \texttt{xP} or \texttt{yP} is rejected, \texttt{sumP} is rejected with the same reason.

\paragraph{Q.join} Join is our eventual equality operation. \texttt{Q.join(xP,yP)} takes two promises \texttt{xP} and \texttt{yP} and returns a joined promise. Any messages sent to this joined promise are only delivered if \texttt{xP} and \texttt{yP} eventually come to designate the same target object. If this is the case, all messages are eventually delivered to that target and the joined promise itself eventually becomes fulfilled to designate that target. Otherwise, all these messages are discarded with the usual rejected promise contagion.

\begin{verbatim}
Q.join = (xP, yP) => {
  return Q.all([xP, yP]).then(([x, y]) => {
    if (x === y) {
      return x;
    } else {
      throw new Error("not the same");
    }
  });
};
\end{verbatim}

\subsection{NodeKen: Distributed Orthogonal Persistence}

Electronic rights require a distributed, secure, and persistent computational fabric.
We have already covered the distributed and secure aspects of Dr. SES. Here, we cover the final aspect of resilience against failures.

To introduce resilience against failures, Dr. SES builds upon the Ken protocol~\cite{Yoo:CKen}. It offers to applications two primary features:

\begin{description}
  \item[Reliable messaging] Ken provides primitives to reliably transmit a message exactly once to a recipient process. In addition, multiple messages sent to the same recipient are guaranteed to arrive in the same order (i.e. Ken ensures pair-wise FIFO message ordering).
  \item[Distributed consistent snapshots] Ken provides to applications a persistent object heap. All objects allocated in this heap will survive arbitrary failures. Ken further ensures that the snapshots of distributed processes does not grow inconsistent. For example, it is impossible for the sender of a message to record in its snapshot that the message was successfully delivered, while the receiver has no record of having processed that message in its snapshot.
\end{description}

In short, a Ken process can tolerate arbitrary failures in such a way that when an application is restarted after a crash, it is automatically restored to a state that is consistent with the state before the crash. To the process itself, it is as if the crash had never happened. To any of the process's communication partners, the process just seemed slow to respond.

Ken is a protocol best implemented at the level of a virtual machine. Ken assumes communicating event loops, and so aligns well with Javascript's de-facto execution model. A Ken process is an event loop. The way that Ken achieves the above properties is simple, yet effective:

\begin{itemize}
  \item During a turn, all outgoing messages are accumulated in an outgoing message queue. These messages are not yet released to the network.
  \item At the end of each turn, make a checkpoint of the persistent heap and of all outgoing unacknowledged messages.
  \item After the end-of-turn checkpoint is made, release any new outgoing messages to the network and acknowledge the message processed this turn.
  \item Outgoing messages are numbered with a sequence number (for duplicate detection and message ordering).
  \item Unacknowledged outgoing messages are periodically retried (with exponential back-off) until an acknowledgement is received.
  \item Incoming messages are checked for duplicates. When a duplicate message is detected, it is dropped (not processed) and immediately acknowledged.
\end{itemize}

The snapshot of a Ken process consists of both the heap and the outgoing message queue. It does not include the runtime stack (which is guaranteed to be empty between two turns) nor the incoming message queue.

The key point is that outgoing messages are released, and incoming messages are acknowledged only \emph{after} the message has been fully processed by the receiver \emph{and} the heap state has been checkpointed.

The Ken protocol guarantees distributed snapshots even in the face of mutual suspicion. There is nothing an adversarial process can do that will corrupt the distributed snapshots of benign processes.

One assumption that Ken does make is that all Ken processes eventually recover. To Ken, a permanently crashed client is indistinguishable from a very slow client. Thus, while Ken guarantees exactly-once message delivery, it is still up to the application to do its own failure handling if it does not receive a response within a given timeout period.

One objection against the Ken approach to checkpointing is that making a checkpoint after every event loop turn is too costly. The Ken implementation currently makes use of the OS virtual memory paging system to save to disk only those parts of the heap that have changed while processing a message. Furthermore, the availability of cheap low-latency non-volatile memory (such as solid-state drives) has driven down the cost of writing state to disk to the point that making micro-snapshots after every turn becomes practical.

To date, there exist two implementations of the Ken protocol, one in C (CKen~\cite{Yoo:CKen}) and one in Java (WaterKen~\cite{waterken}). We are actively working towards integrating CKen with the v8 Javascript virtual machine\footnote{See \url{https://github.com/supergillis/v8-ken}.}. The longer-term goal is to integrate such a Ken-aware v8 runtime platform with node.js (which is built on v8), to arrive at what we call NodeKen. The key idea is to turn node.js into a Ken process, enabling distributed orthogonal persistence of server-side Javascript programs.

\bnote{tom}{TODO: Brian Warner's sketch of secure communications. (NACL Library)}

\section{Contracts use Electronic Rights}

\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
var makeMint = () => {
  var amp = WeakMap();
  var makePurse = () => mint(0);
  
  var mint = balance => {
    var purse = def({
      getBalance: () => balance,
      makePurse: makePurse,
      deposit: (amount, src) => {
        Nat(balance + amount);
        amp.get(src)(Nat(amount)); 
        balance += amount; 
      } 
    });
    amp.set(purse, 
            amount => { balance = Nat(balance - amount); });
    return purse;
  };
  return mint;
};
\end{verbatim}
\caption{The Mint Maker (19 lines)}
\label{makeMint}
\end{center}
\end{figure}


Contracts generally manipulate rights. The parties to the contract each bring the rights the contract will manipulate, and the logic of the contract together with the decisions of the players determines which derived rights they each walk away with. The simplest example is a direct trade. Since half the rights exchanged in most trades are money, let's start with money. 

Figure~\ref{makeMint}  is our implementation of a money-like rights issuer, using only elements of Dr. SES explained above. To explain how it works, it is best to start with how it is used. Say Alice wishes to buy something from Bob for \$10. The three parties involved would be Alice, Bob, and a \$ issuer, which we will informally call a bank. The starting assumptions are that Alice and Bob do not trust each other, the bank does not trust either Alice or Bob, and Alice and Bob trust the bank with their money but with nothing else. In this scenario, Alice is willing to risk her \$10 on the possibility of Bob's non-delivery. But Bob wants to be sure he's been paid before he releases the good in exchange.

What do these initial conditions mean in terms of a configuration of persistent objects? Say Alice owns (or is) a set of objects on machine A, Bob on machine B, and the bank on machine C. In order for Alice to be able to make a {\tt buy} request of Bob, we assume one of Alice's objects already has a remote reference to an object of Bob's objects. Alice's trust of the bank with her money is represented by a remote reference to an object within the bank representing Alice's account at the bank. We refer to such objects as \emph{purses}. The one representing Alice's account is Alice's \emph{main purse}. And likewise for Bob. Where do these initial account purses come from?

For each currency the bank wishes to manage, the bank calls {\tt makeMint()} once to get a {\tt mint} function for making purses holding units of that currency. When Alice opens an account with, say \$100 in cash, the bank calls {\tt mint(100)} on its \$ mint, to make Alice's main purse. The bank then gives Alice a persistent remote reference to this object within the bank.

For Alice to pay Bob, she sets up a \emph{payment purse}, deposits \$10 into it from her main purse, and sends it to Bob in a buy request, together with a description of what she wishes to buy.
\begin{verbatim}
  var paymentP = myPurse ! makePurse();
  var ackP = paymentP ! deposit(10, myPurse);
  var goodP = ackP.then(_ => bobP ! buy(desc, paymentP));
\end{verbatim}

\bnote{Mark}{If we could assume E-order, we could omit the ackP above, as I normally do in my talks. OTOH, if we could assume FIFO, we could omit the first .then below. Unfortunately, I don't think Q should commit yet to either choice.}

Bob receives this request at the following {\tt buy} method:
\begin{verbatim}
  buy: (desc, paymentP) => {
    // do whatever with desc, look up $10 price
    return Q(paymentP).then(
      p => (myPurse ! deposit(10, p)).then(
        _ => good,
        // failure handling...
\end{verbatim}

Bob's {\tt buy} method handles a message from untrusted clients such as Alice, and thus it does not know what objects Alice actually provided as the arguments. In particular, Bob has no idea if his {\tt paymentP} parameter actually designates a purse, whether it is a purse at this bank, of this currency, and of adequate funds. Even if he knew all these conditions were true at the moment, since Bob doesn't know whether Alice still retains access to it, Bob wouldn't know the funds would still be there by the time he deposits it. He delegates all these problems to the bank with the {\tt deposit} request above. If the bank's deposit method acknowledges a successful deposit, by fulfilling the promise for the result of the deposit, then the success callback of the second {\tt then} above gets called, returning the {\tt good}, resolving Alice's pending {\tt goodP} promise.

\bnote{Mark}{I know that I'm saying *way* too much. But it's easier to generate and trim than to try to say just enough directly.}
Following {\tt deposit} sequentially, we see it
\begin{enumerate}
\item Uses {\tt Nat} to ensure that the new {\tt balance} would not overflow the range of reliably represented non-negative integers. Otherwise an error is thrown, breaking Bob's promise for the result of the deposit, and the good is not released back to Alice.
\item Looks up the alleged payment purse in the {\tt amp} table. If this is anything other than a purse of the same currency at the same bank, this lookup will instead return undefined, causing the following function call to throw an error.
\item If this lookup succeeds, it find {\tt amount => { balance = Nat(balance - amount); })} function that was registered with this payment purse when that payment purse was created. The {\tt balance} in that function refers to the payment purse's {\tt balance}. 
\item After checking that the amount to be deposited is indeed a non-negative integer, this function is called to withdraw that amount from the payment purse.
\item If the payment has insufficient funds, {\tt balance - amount} would be negative and {\tt Nat} would throw.
\item This is the commit point. All the tests that might cause failure have already passed, and no side effects have yet happened. Now we perform all side effects, all of which will happen since no potential locally observable failures remain.
\item The assignment decrements the balance by the amount. This function now returns and we continue with rest of the {\tt deposit} method.
\item The {\tt +=} increments the balance of purse being deposited into.
\item The {\tt deposit} method implicitly returns undefined, fulfilling Bob's promise for the result if the deposit, triggering Bob to release the good to Alice in exchange.
\end{enumerate}

\bnote{Mark}{The reason I don't reuse the result of adding balance and amount, but rather re-add them, is to defend against an aliasing attack, where the same purse is used as receiver and argument.}

\section{Towards a Taxonomy of Electronic Rights}

The local unforgeable object reference and the remote unguessable object reference represent one kind of eright---the eright to invoke the public interface of the object it designates. The Mint Maker, building on object references as erights, builds a new kind of eright at a new level of abstraction, one having many of the properties of money. By contrasting these, we can begin to form a taxonomy of erights, and to understand how the layers of abstractions relate to each other. 

\begin{tabular}{ l l }
  Object reference & Money \\ \hline
  Shared & Exclusive \\
  Specific & Fungible \\
  Opaque & Assayable \\
  Exercisable & Symbolic \\
\end{tabular}\\

When Alice sends the payment purse to Bob, she has \emph{shared} with Bob access to this purse object. If Bob's {\tt deposit} message to his main purse succeeds, Bob obtains \emph{exclusive} access to this money, denying Alice any further access.

The reference to the payment purse designates a \emph{specific} object, this payment purse as opposed to any other. Whereas the counters in the purses represent only quantities of money (though still specific to a given currency at a given issuer). Bob doesn't care which of these \$s he gets, so long as he gets the amount he expects.

When Bob receives access to the payment purse, he doesn't know what it is except that it is some object that one of his clients chose to send him in this argument position. If his {\tt deposit} method succeeds, he knows exactly what money rights he has received.

By sending a message to an object, one \emph{exercises} whatever erights to cause effects are provided by that object's public interface. By contrast, money is only valuable because it is valued by others. Money does not have any direct use-value.

These four dimensions are only a start. It is not clear even that all 16 combinations are useful, but clearly many are. To have an expressive system of erights, we wish to be able to express many of these easily. But to have a small kernel, we wish to build directly on only the minimal set needed to be able to build the rest easily. Experiments so far, such as the Mint Maker, indicate that object-references are indeed a good choice of kernel eright.

\section{The Escrow Exchange Contract}

\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
var transfer = (decisionP, srcPurseP, dstPurseP, amount) => {
  var makeEscrowPurseP = Q.join(srcPurseP ! makePurse, 
                                dstPurseP ! makePurse);
  var escrowPurseP = makeEscrowPurseP ! ();

  Q(decisionP).then(                              // setup phase 2
    _      => { dstPurseP ! deposit(amount, escrowPurseP); },
    reason => { srcPurseP ! deposit(amount, escrowPurseP); });

  return escrowPurseP ! deposit(amount, srcPurseP);     // phase 1
};

var failOnly = cancelP => Q(cancelP).then(
  cancel => { throw cancel; });

var escrowExchange = (a, b) => { // a from Alice, b from Bob
  var decide;
  var decisionP = Q.promise(resolve => { decide = resolve; });

  decide(Q.race([Q.all([
     transfer(decisionP, a.moneySrcP, b.moneyDstP, b.moneyNeeded),
     transfer(decisionP, b.stockSrcP, a.stockDstP, a.stockNeeded)
    ]), 
    failOnly(a.cancelP), 
    failOnly(b.cancelP)]));
  return decisionP;
};
\end{verbatim}
\caption{The Escrow Exchange Contract (22 lines)}
\label{escrowExchange}
\end{center}
\end{figure}



\section{The Contract Host}

\begin{figure}[htbp]
\begin{center}
\begin{verbatim}
var makeContractHost = () => {
  var amp = WeakMap();

  return def({
    setup: contractSrc => {
      contractSrc = ''+contractSrc;
      var contract = confine(contractSrc, {Q: Q});
      var resolve;
      var resultP = Q.promise(r => { resolve = r; });
      var tokens = [];
      var argPs = [];

      var addParam = (i, token) => {
        tokens[i] = token;
        var resolveArg;
        argPs[i] = Q.promise(r => { resolveArg = r; });
        amp.set(token, (allegedSrc, allegedI, arg) => {
          if (contractSrc !== allegedSrc) {
            throw new Error('unexpected contract: '+contractSrc);
          }
          if (i !== allegedI) {
            throw new Error('unexpected player number: '+i);
          }
          amp.delete(token);
          resolveArg(arg);
          return resultP;
        });
      };
      for (var i = 0; i < contract.length; i++) {
        addParam(i, def({}));
      }
      resolve(Q.all(argPs).then(args => contract(...args)));
      return tokens;
    },
    play: (tokenP, allegedSrc, allegedI, arg) => Q(tokenP).then(
      token => amp.get(token)(allegedSrc, allegedI, arg))
  });
};
\end{verbatim}
\caption{The Contract Host (36 lines)}
\label{makeContractHost}
\end{center}
\end{figure}

\section{A More Cooperative World?}

\bibliographystyle{splncs}
% \bibliographystyle{alpha}
\bibliography{common}

\end{document}
