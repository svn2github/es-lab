\documentclass{llncs}
\usepackage{makeidx}  
% \usepackage{hyperref}
\begin{document}
\sloppypar


\title{Distributed Electronic Rights in JavaScript:\\
A Progress Report}

\author{Mark S. Miller\inst{1} \and Tom Van Cutsem\inst{2} \and Bill Tulloh\inst{3} }

\institute{Google, Inc. \and V.U.B \and George Mason University}

\maketitle    

\begin{abstract}

Smart Contracts are cool.

\keywords{security, distributed objects, capabilities, smart contracts}
\end{abstract}

\section{Smart Contracts for the Rest of Us}

The fabric of the global economy is held together by contracts. A contract is an agreed arrangement for cooperation between mutually suspicious parties. But existing contracts are ambiguous, jurisdictions-specific, and written, interpreted, and adjudicated only by expensive experts. \emph{Smart contracts} are contract-like arrangements expressed in program code, where the behavior of the program enforces the terms of the ``contract''\cite{szabo1997formalizing}. Though not a substitute for legal contracts, they can provide some of the benefits of contracts for fine-grain, jurisdiction-free, and automated arrangements for which legal contracts are impractical.

To realize this potential, smart contracts themselves need a distributed, secure, and persistent computational fabric. To avoid merely substituting one set of expensive experts for another, non-experts should be able to write smart contracts understandable by other non-experts.

We are working towards turning JavaScript into such a fabric. JavaScript is already understood and used by massive numbers of non-expert programmers. We call our target JavaScript platform \emph{Dr. SES} for \emph{Distributed Resilient Secure EcmaScript}\footnote{The official standards name for JavaScript is ``EcmaScript''.}. We explain how it relates to today's JavaScript, and report on our progress building Dr. SES. To demonstrate that Dr. SES would be a suitable platform, we present a representative simple smart contract, \emph{secure distributed escrow exchange}, implemented in only 41 lines of straightforward JavaScript code. We also present a generic contract host, able to host this contract and others, in only 36 lines.

\section{Dr. SES: Distributed Resilient Secure EcmaScript}

The current JavaScript standard, EcmaScript 5 (ES5), enables the \emph{SES} library to easily enforce local object-capability security rules on newly loaded JavaScript code. The \emph{Q} library turns JavaScript into a securable distributed object system, spanning both browsers and servers. And the \emph{NodeKen} project is layering the Node server-side JavaScript implementation onto the Ken system for distributed orthogonal persistence -- resilient against many failures. We explain each below.

\subsection{Just Enough JavaScript}

JavaScript is a complex language, but this paper depends only on a small subset with two core constructs, \emph{functions} and \emph{records}. 

For the sake of brevity, this paper borrows two syntactic conveniences proposed for ES6, \emph{rest arguments}(``{\tt \ldots}'') and \emph{arrow functions}(``{\tt =>}''), and one proposed for ES7, the \emph{eventual-send operator}(``{\tt !}''). Expanding away these three conveniences, all the code here is working ES5 code, and is available at \\
{\tt code.google.com/p/es-lab/source/browse/trunk/src/ses/\#ses} \\
and its {\tt contract} subdirectory.

\paragraph{Rest arguments.} ES6 provides ``{\tt \ldots}'' as a syntactic convenience for applying a function to an array of arguments. The following three lines are equivalent, but the second line is of historic interest only.

\begin{verbatim}
  foo(3, 5)                 // normal fixed arity function call
  foo.apply(void 0, [3, 5]) // old way to apply to an array
  foo(...[3, 5])            // ES6 rest args used in this paper
\end{verbatim}

\paragraph{Arrow functions.} The following five lines all define a one parameter function which returns double its parameter. All bind a local variable named ``{\tt double}'' to this function. The first two lines are of historic interest only. This paper uses only the arrow function syntax of the last three lines.

\begin{verbatim}
  function double(n) { return n+n; }        // old function decl
  var double = function(n) { return n+n; }; // old function expr
  var double = (n) => { return n+n; };      // ES6 arrow function
  var double = (n) => n+n;    // non-"{" expr implicitly returned
  var double = n => n+n;      // parens optional if one param
\end{verbatim}

\paragraph{Records.} The record syntax {\tt \{x: 3, y: 4\}} is an expression that evaluates to a record with two named fields initialized to the values shown. Records and functions compose together naturally to give objects:

\begin{verbatim}
var makePoint = (x, y) => {
  return {
    getX: () => x,
    getY: () => y,
    add: other => makePoint(x + other.getX(), y + other.getY())
  };
};

var pt = makePoint(3, 5).add(makePoint(2, 7));
\end{verbatim}

A record of functions hiding variables serves as an object of methods ({\tt getX, getY, add}) hiding instance variables ({\tt x, y}). The {\tt makePoint} function serves as a class-like factory for making new point instances.


\subsection{SES: Securing JavaScript}




From a security perspective, there were three problems with such objects: 
\begin{itemize}
\item Records were fully mutable, allowing one client of a point to, for example, replace its {\tt getX} method, violating the assumptions of other clients. ES5 provides a {\tt freeze} primitive, used by the SES library to define the {\tt def} function for making a tamper proof object graph.
\item ES3 had six violations of static scoping. Three of these are fixed unconditionally by ES5. In addition, ES5 provides a \emph{strict mode}, enabled by the {\tt "use strict";} directive shown below, which fixes the remaining three violations. (Throughout the rest of this paper, strict mode is assumed without further notation.)  
\item Even aside from these scoping violations, ES3 functions were not encapsulated. However, ES5 strict functions are fully encapsulated.
\end{itemize}

\begin{verbatim}
"use strict";
var makePoint = (x, y) => {
  return def({
    getX: () => x,
    getY: () => y,
    add: other => makePoint(x + other.getX(), y + other.getY())
  });
};
\end{verbatim}

A \emph{tamper-proof} record of \emph{encapsulated} functions hiding \emph{lexical} variables serves as a \emph{defensible} object. An object is ``defensible'' if it can be straightforwardly coded to be \emph{defensively consistent}\cite{RobustComposition}, i.e., it can defend its own invariants and provide correct service to its well behaved clients despite arbitrary or malicious misbehavior by its other clients. Our revised {\tt makePoint} above makes defensively consistent points.

Other SES elements: 
All effects only by using references.
No powerful references by default -- all implicitly shared objects are transitively immutable. 

def
confine
Nat
WeakMap

\subsection{Q: Distributed JavaScript Objects}

Communicating Event-Loop Concurrency

Immediate call and eventual send

Promises, local and remote

Bang syntax and its expansion

Distributed cryptographic-capabilities

\subsection{NodeKen: Distributed Orthogonal Persistence}

Assumes asynchronously communicating event loops.

Number outgoing messages.
Retry unacknowledged outgoing messages.
Drop duplicate incoming messages.
Don't release messages or acknowledgments except from a checkpointed state.

Brian Warner's sketch of secure communications.

\section{Contracts use Electronic Rights}
\section{Towards a Taxonomy of Electronic Rights}
\section{The Contract Host}
\section{Contracts create Electronic Rights}
\section{A More Cooperative World?}

\bibliographystyle{splncs}
% \bibliographystyle{alpha}
\bibliography{common}


\appendix

\section{The Mint Maker (19 lines)}

\begin{verbatim}
var makeMint = () => {
  var amp = WeakMap();
  var makePurse = () => mint(0);
  var mint = balance => {
    var purse = def({
      getBalance: () => balance,
      makePurse: makePurse,
      deposit: (amount, src) => {
        Nat(balance + amount);
        amp.get(src)(Nat(amount)); 
        balance += amount; 
      } 
    });
    amp.set(purse, 
            amount => { balance = Nat(balance - amount); });
    return purse;
  };
  return mint;
};
\end{verbatim}

\section{The Escrow Exchange Agent (22 lines)}

\begin{verbatim}
var transfer = (decisionP, srcPurseP, dstPurseP, amount) => {
  var makeEscrowPurseP = Q.join(srcPurseP ! makePurse, 
                                dstPurseP ! makePurse);
  var escrowPurseP = makeEscrowPurseP ! ();

  Q(decisionP).then(                              // setup phase 2
    _      => { dstPurseP ! deposit(amount, escrowPurseP); },
    reason => { srcPurseP ! deposit(amount, escrowPurseP); });

  return escrowPurseP ! deposit(amount, srcPurseP);     // phase 1
};

var failOnly = cancelP => Q(cancelP).then(
  cancel => { throw cancel; });

var exchange = (a, b) => { // a from Alice, b from Bob
  var decide;
  var decisionP = Q.promise(resolve => { decide = resolve; });

  decide(Q.race([Q.all([
     transfer(decisionP, a.moneySrcP, b.moneyDstP, b.moneyNeeded),
     transfer(decisionP, b.stockSrcP, a.stockDstP, a.stockNeeded)
    ]), 
    failOnly(a.cancelP), 
    failOnly(b.cancelP)]));
  return decisionP;
};
\end{verbatim}

\section{The Contract Host (36 lines)}

\begin{verbatim}
var makeContractHost = () => {
  var amp = WeakMap();

  return def({
    setup: contractSrc => {
      contractSrc = ''+contractSrc;
      var contract = confine(contractSrc, {Q: Q});
      var resolve;
      var resultP = Q.promise(r => { resolve = r; });
      var tokens = [];
      var argPs = [];

      var addParam = (i, token) => {
        tokens[i] = token;
        var resolveArg;
        argPs[i] = Q.promise(r => { resolveArg = r; });
        amp.set(token, (allegedSrc, allegedI, arg) => {
          if (contractSrc !== allegedSrc) {
            throw new Error('unexpected contract: '+contractSrc);
          }
          if (i !== allegedI) {
            throw new Error('unexpected player number: '+i);
          }
          amp.delete(token);
          resolveArg(arg);
          return resultP;
        });
      };
      for (var i = 0; i < contract.length; i++) {
        addParam(i, def({}));
      }
      resolve(Q.all(argPs).then(args => contract(...args)));
      return tokens;
    },
    play: (tokenP, allegedSrc, allegedI, arg) => Q(tokenP).then(
      token => amp.get(token)(allegedSrc, allegedI, arg))
  });
};
\end{verbatim}


\end{document}
